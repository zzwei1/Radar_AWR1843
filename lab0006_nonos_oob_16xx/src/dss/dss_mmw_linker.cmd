
/* Linker Settings                                                            */
--retain="*(.intvecs)"

--stack_size=0x700

#define L1P_CACHE_SIZE (16*1024)
#define L1D_CACHE_SIZE (16*1024)


MEMORY
{
PAGE 0:

#if (L1P_CACHE_SIZE < 0x8000)
    L1PSRAM:        o = 0x00E00000, l = (0x00008000 - L1P_CACHE_SIZE)
#endif
#if (L1D_CACHE_SIZE < 0x8000)
    L1DSRAM:        o = 0x00F00000, l = (0x00008000 - L1D_CACHE_SIZE)
#endif
    L2SRAM_UMAP1:   o = 0x007E0000, l = 0x00020000
    L2SRAM_UMAP0:   o = 0x00800000, l = 0x00020000
    L3SRAM:         o = 0x20000000, l = 0x000C0000
    HSRAM:          o = 0x21080000, l = 0x8000

    /* PAGEs 1 and onwards are for overlay purposes for memory optimization.
       Some examples:
       1. Overlay one-time only text with uninitialized data.
       2. Overlay L1PSRAM data path processing fast code and use copy tables
          to page in (before entering data path) and out of L1PSRAM (when entering
          sleep/low power).
    */
PAGE 1:
    L3SRAM:         o = 0x20000000, l = 0x000C0000
}


SECTIONS
{
	GROUP
	{
	    /* hard addresses forces vecs to be allocated there */
	    .vector0:      {. = align(32);}
		.vector1:      {. = align(32);}
		.vector2:      {. = align(32);}
		.vector3:      {. = align(32);}
		.vector4:      {. = align(32);}
		.vector5:      {. = align(32);}
		.vector6:      {. = align(32);}
		.vector7:      {. = align(32);}
		.vector8:      {. = align(32);}
		.vector9:      {. = align(32);}
		.vector10:      {. = align(32);}
		.vector11:      {. = align(32);}
		.vector12:      {. = align(32);}
		.vector13:      {. = align(32);}
		.vector14:      {. = align(32);}
		.vector15:      {. = align(32);}
    } > L2SRAM_UMAP1

    /* Allocate data preferentially in one UMAP and code (.text) in another,
       this can improve performance due to simultaneous misses from L1P
       and L1D caches to L2 SRAM, for more information see C674 Megamodule
       User Guide section "Level 2 Memory Architecture".
       The linker notation "X >> Y | Z" indicates section X is first allocated in Y
       and allowed to overflow into Z and can be split from Y to Z.
       The linker notation "X > Y | Z" indicates section X is first allocated in Y
       and allowed to overflow into Z and cannot be split from Y to Z. Some sections
       like bss are not allowed to be split so > notation is used for them */

    .fardata:  {} >> L2SRAM_UMAP0 | L2SRAM_UMAP1
    .const:    {} >> L2SRAM_UMAP0 | L2SRAM_UMAP1
    .switch:   {} >> L2SRAM_UMAP0 | L2SRAM_UMAP1
    .cio:      {} >> L2SRAM_UMAP0 | L2SRAM_UMAP1
    .data:     {} >> L2SRAM_UMAP0 | L2SRAM_UMAP1
    .rodata:   {} >> L2SRAM_UMAP0 | L2SRAM_UMAP1

    .bss:      {} > L2SRAM_UMAP0 | L2SRAM_UMAP1
    .neardata: {} > L2SRAM_UMAP0 | L2SRAM_UMAP1
    .stack:    {} > L2SRAM_UMAP0 | L2SRAM_UMAP1
    .cinit:    {} > L2SRAM_UMAP0 | L2SRAM_UMAP1
    .far:      {} > L2SRAM_UMAP0 | L2SRAM_UMAP1

    .text: {} >> L2SRAM_UMAP1 | L2SRAM_UMAP0
}

/* Section Configuration                                                      */
SECTIONS
{
    systemHeap : {} >> L2SRAM_UMAP0 | L2SRAM_UMAP1
    .l2data : {} >> L2SRAM_UMAP0 | L2SRAM_UMAP1

    /* HSSRAM has output data from processing chain running on DSP */
    .demoSharedMem > HSRAM

    /* L3SRAM has code that is overlaid with data, so data must be
       marked uninitialized. Application can initialize this section
       using _L3data_* symbols defined below. Code should be written carefully as
       these are linker symbols (see for example http://e2e.ti.com/support/development_tools/compiler/f/343/t/92002 ):

        extern far uint8_t _L3data_start; // the type here does not matter
        extern far uint8_t _L3data_size;  // the type here does not matter

        memset((void *)_symval(&_L3data_start), 0, (uint32_t) _symval(&_L3data_size));
    */
    .l3data: type=NOINIT, start(_L3data_start), size(_L3data_size), load=L3SRAM PAGE 1

    /* Bootloader cannot load L1DSRAM, make sure to mark as NOINIT */
    .l1data : type=NOINIT, load=L1DSRAM

    /* This is auto generated by linker related to copy table above */
    .ovly > L2SRAM_UMAP0 | L2SRAM_UMAP1

    /* Overlay one-time/init-time (and non-critical in cycles) with L3 data,
       will be erased during data path processing. Note do not put any
       code that is required related to start/stop/reconfig processing */
    .overlay:
    {
        dss_main.oe674 (.text:MmwDemo_dssInitTask)
        dss_main.oe674 (.text:main)
        dss_data_path.oe674 (.text:MmwDemo_dataPathInitEdma)
    } > L3SRAM PAGE 0

}

